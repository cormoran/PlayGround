/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package armeriatest;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ThreadFactory;

import com.linecorp.armeria.common.HttpRequest;
import com.linecorp.armeria.common.HttpResponse;
import com.linecorp.armeria.common.logging.RequestLogProperty;
import com.linecorp.armeria.common.util.EventLoopGroups;
import com.linecorp.armeria.common.util.ThreadFactoryBuilder;
import com.linecorp.armeria.server.DecoratingHttpServiceFunction;
import com.linecorp.armeria.server.HttpService;
import com.linecorp.armeria.server.Server;
import com.linecorp.armeria.server.ServiceRequestContext;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.netty.channel.EventLoopGroup;
import io.netty.util.concurrent.CompleteFuture;

public class App {
    private Logger logger = LoggerFactory.getLogger(App.class);

    public HttpResponse delayService(ServiceRequestContext ctx, HttpRequest req) {
        try {
            Thread.sleep(500);
        } catch (Exception e) {
        }
        return HttpResponse.of("OK");
    }

    public HttpResponse paramDelayService(ServiceRequestContext ctx, HttpRequest req) {
        final long delay = Integer.parseInt(ctx.pathParam("delay"));
        try {
            Thread.sleep(delay);
        } catch (Exception e) {
        }
        return HttpResponse.of("OK");
    }

    public HttpResponse paramDelayRequestAggregateService(ServiceRequestContext ctx, HttpRequest req) {
        req.aggregate().join();
        final long delay = Integer.parseInt(ctx.pathParam("delay"));
        try {
            Thread.sleep(delay);
        } catch (Exception e) {
        }
        return HttpResponse.of("OK");
    }

    public HttpResponse paramDelayAsyncService(ServiceRequestContext ctx, HttpRequest req) {
        CompletableFuture<HttpResponse> f = new CompletableFuture<>();
        ctx.blockingTaskExecutor().execute(() -> {
            final long delay = Integer.parseInt(ctx.pathParam("delay"));
            try {
                Thread.sleep(delay);
            } catch (Exception e) {
            }
            f.complete(HttpResponse.of("OK"));
        });
        return HttpResponse.from(f);
    }

    public HttpResponse paramDelayRequestAggregateAsyncService(ServiceRequestContext ctx, HttpRequest req) {
        CompletableFuture<HttpResponse> f = new CompletableFuture<>();
        ctx.blockingTaskExecutor().execute(() -> {
            req.aggregate().join();
            final long delay = Integer.parseInt(ctx.pathParam("delay"));
            try {
                Thread.sleep(delay);
            } catch (Exception e) {
            }
            f.complete(HttpResponse.of("OK"));
        });
        return HttpResponse.from(f);
    }

    public HttpResponse completeLogDecorator(HttpService delegate, ServiceRequestContext ctx, HttpRequest req)
            throws Exception {
        final long T = 1000000;
        ctx.log().whenRequestComplete()
                .thenRun(() -> {
                    logger.info("request complete");
                });
        ctx.log().whenComplete()
                .thenAccept(log -> {
                    final long diffNanos = log.totalDurationNanos()
                            - log.requestDurationNanos()
                            - log.responseDurationNanos();
                    logger.info("response complete for " + log.requestHeaders().path() + "\n" +
                            "ReqDuration " + log.requestDurationNanos() / T + " ms\n" +
                            "ResDuration " + log.responseDurationNanos() / T + " ms\n" +
                            "Total       " + log.totalDurationNanos() / T + " ms\n" +
                            "Diff        " + diffNanos / T + " ms");
                });
        ctx.log().whenAvailable(RequestLogProperty.REQUEST_START_TIME)
                .thenAccept(log -> logger.info("ReqStart " + log.requestStartTimeNanos() / T));
        ctx.log().whenAvailable(RequestLogProperty.REQUEST_END_TIME)
                .thenAccept(log -> logger.info("ReqEnd   " + log.requestEndTimeNanos() / T));
        ctx.log().whenAvailable(RequestLogProperty.REQUEST_START_TIME)
                .thenAccept(log -> logger.info("ResStart " + log.responseStartTimeNanos() / T));
        ctx.log().whenAvailable(RequestLogProperty.REQUEST_END_TIME)
                .thenAccept(log -> logger.info("ResEnd   " + log.responseEndTimeNanos() / T));
        return delegate.serve(ctx, req);
    }

    public static void main(String[] args) {
        App app = new App();
        Server.builder()
                .workerGroup(EventLoopGroups.newEventLoopGroup(10, new ThreadFactory() {
                    @Override
                    public Thread newThread(Runnable arg0) {
                        // TODO Auto-generated method stub
                        return null;
                    }
                }), true)
                .decorator(app::completeLogDecorator)
                .service("/delay", app::delayService)
                .service("/paramDelay/:delay", app::paramDelayService)
                .service("/paramDelayReqAggregate/:delay", app::paramDelayRequestAggregateService)
                .service("/paramDelay/async/:delay", app::paramDelayAsyncService)
                .service("/paramDelayReqAggregate/async/:delay", app::paramDelayRequestAggregateAsyncService)
                .http(8080).build().start().join();
    }
}
